#!/usr/bin/python

"""
    python-pycurl
    pyhon-requests

    - progress callback
    - limit download rate
    - keepalive
    - multipart download
"""


import re
import sys
import time
import m3u8
import fcntl
import prctl
import urllib
import os.path
import requests
import threading
import subprocess
from   urlparse    import urlparse, urlunparse

PERCENT = 0
LOCK    = threading.Lock()

def progression(percent):
    global PERCENT

    PERCENT = percent
    LOCK.release()


def download_http(source, destination='/tmp/foobar', progress_clb=None, params={}):
    global max
    current, max = 0, 9999999999999

    def on_response(resp):
        global max
        print resp.url, resp.headers
        max = int(resp.headers.get('content-length', 9999999999999999))

    out = file(destination, 'wb')
    req = requests.get(source, headers=params, stream=True, hooks={'response': on_response})
    while not EXIT:
        data = req.raw.read(4096)
        if len(data) == 0:
            break
                
        out.write(data)
        if progress_clb is not None:
            current += len(data)
            progress_clb(float(current)/max)
    out.close()


def download_stack(source, destination='/tmp/foobar', progress_clb=None):
    prctl.set_name('STACK downloader')

    i = 1
    # removing heading 'stack://'
    for part in source[8:].split(','):
        uri, params = part.strip().split('|')
        params = dict([(urllib.unquote(k), urllib.unquote(v)) for (k,v) in [p.strip().split('=') for p in params.split('&')]])
        print uri, params

        d = match_downloader(uri)
        if d is None:
            print "stack:: no downloader found for '%s' uri" % uri; continue

        _dest = destination.rsplit('.',1)[0] + ("-%02d" % i) + ('.'+destination.rsplit('.',1)[1] if '.' in destination else '')
        d(uri, _dest, progress_clb, params)
        i += 1

        if EXIT:
            break

    lock_release()


def download_m3u8(source, destination='/tmp/foobar', progress_clb=None):
    prctl.set_name('M3U8 downloader')
    baseuri = urlparse(source)
    m3u     = m3u8.load(source)
    print m3u
    #print m3u.segments, m3u.is_variant

    if m3u.is_variant:
        print "VARIANT"
        for item in m3u.playlists:
            print '>',item
            print item.uri, item.stream_info
    else:
        out = file(destination, 'wb')

        nseg = 0
        for segment in m3u.segments:
            nseg += 1
            uri = urlparse(segment.uri)
            if(uri.scheme == ''): #
                uri = (baseuri.scheme, baseuri.netloc, os.path.dirname(baseuri.path) + '/' + uri.path, 
                    uri.params, uri.query, uri.fragment)

            uri = urlunparse(uri)
            #print ">", segment, type(segment), uri
            r = requests.get(uri, stream=True)
            while True:
                data = r.raw.read(4096)
                if len(data) == 0:
                    break
                
                out.write(data)

            if progress_clb is not None:
                progress_clb(float(nseg)/len(m3u.segments))
       
        out.close() 
        LOCK.release()

def download_rtmp(source, destination='/tmp/foobar', progress_clb=None):
    prctl.set_name('RTMP downloader')
    proc = subprocess.Popen(['rtmpdump','-e','-r',source,'-o',destination], 
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT
    )

    loop = True
    def progress():
        prctl.set_name('rtmp progress')

        fd = proc.stdout.fileno()
        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

        while loop:
            try:
                output = proc.stdout.read().strip().split('\n')[-1]
                m = re.match(".*\(([\d\.]+)%\).*", output)
                if m:
                    progress_clb(float(m.group(1))/100)
            except Exception:
                pass

            time.sleep(.5)

    t = threading.Thread(target=progress)
    t.start()
    proc.wait()

    loop = False
    t.join()
    LOCK.release()


def match_downloader(source):
    if source.endswith('.m3u8'):
        return download_m3u8
    else:
        scheme = source.split(':', 1)[0]
        if scheme.startswith('rtmp'):
            return download_rtmp
        elif scheme.startswith('stack'):
            return download_stack
        elif scheme.startswith('http'):
            return download_http

    return None


def download(source, destination, progress_clb):
    dwnloader = match_downloader(source)
    if dwnloader is None:
        print "Cannot download '%s' stream (unknown stream type)" % source; return None
    
    return threading.Thread(target=dwnloader,name='downloader',args=(source, destination, progress_clb))


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print "Usage: %s url [out]" % sys.argv[0]; sys.exit(1)

    t = download(*(sys.argv[1:]+[progression]))
    if t is None:
        sys.exit(1)

    print 'starting downloading...'
    t.start()

    # take a 1st time to lock
    LOCK.acquire()
    while t.is_alive():
        LOCK.acquire()
        print "progression: %2.0f%%" % (PERCENT*100)


    t.join() 
    print 'download complete'

